[
  {
    "title": "Balanced parentheses",
    "description": "Check bracket validity using stack.",
    "sample": "\"{[()]}\" -> true",
    "solution": "function isBalanced(s){const st=[];const map={')':'(',']':'[','}':'{'};for(const ch of s){if('([{'.includes(ch)) st.push(ch); else if(map[ch]){if(st.pop()!==map[ch]) return false;}}return st.length===0;}"
  },
  {
    "title": "Sliding window - longest unique substring",
    "description": "Return length of longest substring without repeating chars.",
    "sample": "\"abcabcbb\" -> 3",
    "solution": "function lengthOfLongestUnique(s){const set=new Set();let l=0,res=0;for(let r=0;r<s.length;r++){while(set.has(s[r])){set.delete(s[l]);l++;}set.add(s[r]);res=Math.max(res,r-l+1);}return res;}"
  },
  {
    "title": "Merge intervals",
    "description": "Merge overlapping intervals.",
    "sample": "[[1,3],[2,6]] -> [[1,6]]",
    "solution": "function merge(intervals){if(!intervals.length) return [];intervals.sort((a,b)=>a[0]-b[0]);const res=[intervals[0]];for(let i=1;i<intervals.length;i++){const last=res[res.length-1];if(intervals[i][0]<=last[1]) last[1]=Math.max(last[1],intervals[i][1]);else res.push(intervals[i]);}return res;}"
  },
  {
    "title": "Top K frequent elements",
    "description": "Return k most frequent elements.",
    "sample": "[1,1,2,2,3],k=2 -> [1,2]",
    "solution": "function topKFrequent(nums,k){const m={};for(const n of nums)m[n]=(m[n]||0)+1;const buckets=[];for(const key in m){const f=m[key];buckets[f]=buckets[f]||[];buckets[f].push(Number(key));}const res=[];for(let i=buckets.length-1;i>=0&&res.length<k;i--)if(buckets[i])res.push(...buckets[i]);return res.slice(0,k);}"
  },
  {
    "title": "Kth smallest in BST (iterative)",
    "description": "Return kth smallest using inorder iteratively.",
    "sample": "BST, k=2",
    "solution": "function kthSmallest(root,k){const st=[];let node=root;while(node||st.length){while(node){st.push(node);node=node.left;}node=st.pop();if(--k===0) return node.val;node=node.right;}return null;}"
  }
]